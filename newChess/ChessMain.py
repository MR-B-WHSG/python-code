"""
This is the main file. It is responsible for handling user input and
displaying the current Game State
"""
"""
This is the main file. It is responsible for handling user input and
displaying the current Game State
"""

import pygame as p
import ChessEngine, ChessAI

boardWidth = boardHeight = 512 #Setting up the size of the screen
moveLogPanelWidth = 350
moveLogPanelHeight = boardHeight
Dimension = 8 #Chess Boards are 8x8
SQ_Size = boardHeight // Dimension #Creating the dimensions of each square as fraction of the screen size
Max_Fps = 20 #For animations
Images = { } #only want to load images once
animate = False # Should only animate when a move is being made not when it is being undone

'''
I am going to load each image once in the main file.
'''

def load_images():
    pieces = ['wp', 'wR', 'wN', 'wB', 'wK', 'wQ', 'bp', 'bR', 'bN','bB', 'bK', 'bQ']
    for piece in piece:
        Images[piece] = p.transform.scale(p.image.load("images/" + piece + ".png"), (SQ_Size, SQ_Size))

# Now I can access any image by just typing Images['pieceName']

'''
This function is responsible for drawing the board and
initialising pygame
It will be in charge of displaying the screen, controlling the
frame rate,
and loading images onto the screen.
'''

def main():
    p.init()
screen = p.display.set_mode((boardWidth + moveLogPanelWidth,boardHeight))
clock = p.time.Clock() #controls the frame rate
screen.fill(p.Color('White'))
moveLogFont = p.font.SysFont('Arial', 18, True, False)
gs = ChessEngine.GameState()
load_images() #will only load the images once
programRunning = True
'''
Initially no square is selected so the tuple will be empty
sqSelected keeps track of the last click from the user
'''
sqSelected = () #use of a tuple (row,col) here instead of having to reference the x and y coordinates
playerClicks = [] #Keeps tracks of the player clicks consisting of two tuples [(3,2), (5,5)]
validMoves = gs.get_valid_moves()
moveMade = False #A new set of valid moves will only be generated if a valid move is made in the first place
gameOver = False

playerOne = True # If a human is playing white then it is True, if an AI is playing then this is False

playerTwo = False # Same as above but for black
while programRunning:
    is_human_turn = (gs.whiteToMove and playerOne) or (not gs.whiteToMove and playerTwo)  # Conditions for the turn to be from a human

    for e in p.event.get():
        if e.type == p.QUIT:
            programRunning = False
        elif e.type == p.MOUSEBUTTONDOWN:
            if not gameOver and is_human_turn:  # only allow mouse clicks if the game has not finished and, it's the human's turn
                location = p.mouse.get_pos()  # This gets the x and y coordinates of the mouse
                col = location[0] // SQ_Size  # columns are the x coordinates
                row = location[1] // SQ_Size  # rows are the y coordinates
                if sqSelected == (row, col) or col >= 8:  # Checks to see if the user clicks the same square twice or if the user clicked the move log
                    sqSelected = ()  # Undoes the sqSelected
                    playerClicks = []  # Clears player clicks
                else:
                    sqSelected = (row, col)
                    playerClicks.append(sqSelected)  # sqSelected clicks get appended to the player clicks (First click and second click)

            if len(playerClicks) == 2:  # Checks for if the second click has been made
                move = ChessEngine.Move(playerClicks[0], playerClicks[1], gs.board)
                print(move.get_chess_notation())
                for i in range(len(validMoves)):
                    if move == validMoves[i]:
                        gs.make_move(validMoves[i])
                        # The only moves able to be made are the moves generated by the engine
                        moveMade = True
                        animate = True
                        sqSelected = ()  # Resets the user clicks so the user can make another move
                        playerClicks = []

        if not moveMade:
            playerClicks = [sqSelected]

        elif e.type == p.KEYDOWN:
            if e.key == p.K_z:  # Undoes the move when z is pressed
                gs.undo_move()
                sqSelected = ()
                playerClicks = []
                moveMade = True
                animate = False
                gameOver = False

            if e.key == p.K_r:  # Resets the board when r is pressed
                gs = ChessEngine.GameState()
                validMoves = gs.get_valid_moves()
                sqSelected = ()
                playerClicks = []
                moveMade = False
                animate = False
                gameOver = False

            # AI move logic
            if not gameOver and not is_human_turn:
                AIMove = ChessAI.find_best_move(gs, validMoves)
                if AIMove is None:
                    AIMove = ChessAI.find_random_move(validMoves)
                gs.make_move(AIMove)
                moveMade = True
                animate = True

            if moveMade:
                if animate:
                    animate_move(gs.moveLog[-1], screen, gs.board, clock)
                validMoves = gs.get_valid_moves()
                moveMade = False
                animate = False
                draw_game_state(screen, gs, validMoves, sqSelected, moveLogFont)

            if gs.checkmate or gs.stalemate:
                gameOver = True

            if gs.stalemate:
                text = 'Stalemate!'
            else:
                if gs.whiteToMove:
                    text = 'Black Wins by Checkmate!'
                else:
                    text = 'White Wins by Checkmate!'
                draw_end_game_text(screen, text)

            clock.tick(Max_Fps)
            p.display.flip()  # Updates the display

def draw_game_state(screen, gs, valid_moves, sq_selected, move_log_font):
    draw_board(screen)  # draws the squares on the board
    highlight_squares(screen, gs, valid_moves, sq_selected)
    draw_pieces(screen, gs.board)  # draws pieces on top of the board
    draw_move_log(screen, gs, move_log_font)

'''
Draws the squares on the board
'''
def draw_board(screen):
    global colours
    colours = [p.Color("white"), p.Color("#BEE5B0")]
    for r in range(Dimension):
        for c in range(Dimension):
            colour = colours[((r + c) % 2)]
            p.draw.rect(screen, colour, p.Rect(c * SQ_Size, r * SQ_Size, SQ_Size, SQ_Size))

'''
Move highlighting - Highlights the piece selected and its possible moves
'''
def highlight_squares(screen, gs, valid_moves, sq_selected):
    if sqSelected != ():  # Makes sure the user hasn't clicked on an end square yet
        r, c = sqSelected
        if gs.board[r][c][0] == ('w' if gs.whiteToMove else 'b'):
            # Makes sure that the square selected is a piece that can be moved
            # Highlighting the selected square
            s = p.Surface((SQ_Size, SQ_Size))
            s.set_alpha(100)  # sets the transparency between 1 and 255
            s.fill(p.Color('blue'))
            screen.blit(s, (c * SQ_Size, r * SQ_Size))

            # Highlighting possible moves
            s.fill(p.Color('red'))
            for move in validMoves:
                if move.startRow == r and move.startCol == c:
                    # Checks if the move starts from the selected square
                    screen.blit(s, (move.endCol * SQ_Size, move.endRow * SQ_Size))

'''
Draws the pieces on the board
'''
def draw_pieces(screen, board):
    for r in range(Dimension):
        for c in range(Dimension):
            piece = board[r][c]
            if piece != '--':
                screen.blit(Images[piece], p.Rect(c * SQ_Size, r * SQ_Size, SQ_Size, SQ_Size))

'''
Draws the move log on the screen
'''
def draw_move_log(screen, gs, font):
    move_log_rectangle = p.Rect(boardWidth, 0, moveLogPanelWidth, moveLogPanelHeight)
    p.draw.rect(screen, p.Color('black'), move_log_rectangle)  # Colour of rectangle

    move_log = gs.moveLog
    move_texts = []
    for i in range(0, len(move_log), 2):
        move_string = str(i // 2 + 1) + '.' + str(move_log[i]) + ' '
        # Makes sure each move is under the same turn (move 1 and 2 is turn 1) (move 5 and 6 is turn 3)
        if i + 1 < len(move_log):  # Makes sure black made a move
            move_string += str(move_log[i + 1]) + ' '
        move_texts.append(move_string)

    moves_per_row = 3
    shift = 5
    texty = shift
    line_space = 2
    for i in range(0, len(move_texts), moves_per_row):
        # Makes sure multiple moves appear on the same line before going to the next line
        text = ''
        for j in range(moves_per_row):
            if i + j < len(move_texts):
                text += move_texts[i + j]
        text_object = font.render(text, True, p.Color('White'))  # Colour of text
        text_location = move_log_rectangle.move(shift, texty)
        screen.blit(text_object, text_location)
        texty += text_object.get_height() + line_space


'''
Move animation
'''
def animate_move(move, screen, board, clock, frame_per_square=None):
    global colours
    difference_in_row = move.endRow - move.startRow
    difference_in_col = move.endCol - move.startCol
    frames_per_square = 10  # frames to move within a square
    frame_count = (abs(difference_in_row) + abs(difference_in_col)) * frame_per_square

    for frame in range(frame_count + 1):
        r, c = (move.startRow + difference_in_row * frame / frame_count,
                move.startCol + difference_in_col * frame / frame_count)  # Forming a ratio of the frames

        draw_board(screen)
        draw_pieces(screen, board)  # Draws the state of the board

        # Need to erase the piece moved from its ending square
        colour = colours[(move.endRow + move.endCol) % 2]
        end_square = p.Rect(move.endCol * SQ_Size, move.endRow * SQ_Size, SQ_Size, SQ_Size)
        p.draw.rect(screen, colour,
                    end_square)  # Draws a rectangle of the correct square to erase the piece from the board

        # Draw the captured piece onto the rectangle
        if move.pieceCaptured != '--':
            if move.isEnpassantMove:  # Fixing previous bug where the captured piece would move to its 'captured position' when it should just stay in the same place
                enpassant_row = (move.endRow + 1) if move.pieceCaptured[0] == 'b' else move.endRow - 1
                end_square = p.Rect(move.endCol * SQ_Size, enpassant_row * SQ_Size, SQ_Size, SQ_Size)
                screen.blit(Images[move.pieceCaptured], end_square)

        # Drawing the moving piece
        screen.blit(Images[move.pieceMoved], p.Rect(c * SQ_Size, r * SQ_Size, SQ_Size, SQ_Size))
        p.display.flip()
        clock.tick(60)


def draw_end_game_text(screen, text):
    font = p.font.SysFont('Helvetica', 40, True, True)
    text_object = font.render(text, 0, p.Color('Gray'))
    text_location = p.Rect(0, 0, boardWidth, boardHeight).move(
        boardWidth / 2 - text_object.get_width() / 2,
        boardHeight / 2 - text_object.get_height() / 2
    )
    screen.blit(text_object, text_location)
    text_object = font.render(text, 0, p.Color('Black'))
    screen.blit(text_object, text_location.move(2, 2))


if __name__ == "__main__":
    main()